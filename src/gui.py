# ==============================================================================
# VISUALIZATION TOOL
# NOTE: This GUI was generated by Gemini 3.0 to demonstrate my
# "Open-Reasoning" engine. The core logic resides in 'search.py'.
# ==============================================================================

import customtkinter as ctk
import tkinter as tk
from tkinter import ttk
import threading
import queue
import time
from chat_engine import ChatEngine
from search import BeamSearch

# --- CONFIGURATION ---
ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("blue")

MODES = {
    "‚ö° Flash": {"width": 1, "depth": 1, "retries": 0, "type": "direct"},
    "ü§î Thinking": {"width": 3, "depth": 7, "retries": 0, "type": "search"},
    "üß† Ultra": {"width": 4, "depth": 10, "retries": 2, "type": "search"}
}


class ModernReasoningApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Open-Reasoning Engine v5.0")
        self.geometry("1400x900")

        self.msg_queue = queue.Queue()
        self.engine = None
        self.current_searcher = None
        self.is_running = False
        self.start_time = 0

        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        self._setup_ui()
        self._setup_tree_style()
        self.after(100, self._process_queue)

    def _setup_tree_style(self):
        """Configures ttk.Treeview to match CustomTkinter dark theme."""
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("Treeview", background="#2b2b2b", foreground="#e0e0e0",
                        fieldbackground="#2b2b2b", bordercolor="#2b2b2b",
                        rowheight=30, font=("Segoe UI", 11))
        style.configure("Treeview.Heading", background="#1f1f1f", foreground="white",
                        relief="flat", font=("Segoe UI", 11, "bold"))
        style.map("Treeview", background=[('selected', '#1f6aa5')])

    def _setup_ui(self):
        # --- LEFT SIDEBAR ---
        sidebar = ctk.CTkFrame(self, width=250, corner_radius=0)
        sidebar.grid(row=0, column=0, sticky="nsew")

        ctk.CTkLabel(sidebar, text="üß† Open-Reasoning", font=ctk.CTkFont(size=22, weight="bold")).pack(pady=30)

        ctk.CTkLabel(sidebar, text="Reasoning Mode:", anchor="w").pack(fill="x", padx=20, pady=(10, 0))
        self.mode_var = ctk.StringVar(value="ü§î Thinking")
        ctk.CTkOptionMenu(sidebar, variable=self.mode_var, values=list(MODES.keys())).pack(fill="x", padx=20, pady=10)

        self.action_btn = ctk.CTkButton(sidebar, text="Start Reasoning", command=self.toggle_search,
                                        height=50, font=ctk.CTkFont(size=14, weight="bold"))
        self.action_btn.pack(fill="x", padx=20, pady=20)

        self.status_label = ctk.CTkLabel(sidebar, text="Ready", text_color="gray", anchor="w")
        self.status_label.pack(side="bottom", fill="x", padx=20, pady=20)

        # --- RIGHT CONTENT ---
        content_frame = ctk.CTkFrame(self, fg_color="transparent")
        content_frame.grid(row=0, column=1, sticky="nsew", padx=20, pady=20)
        content_frame.grid_rowconfigure(1, weight=1)
        content_frame.grid_columnconfigure(0, weight=1)

        self.input_box = ctk.CTkEntry(content_frame, placeholder_text="Enter puzzle...", height=40,
                                      font=ctk.CTkFont(size=14))
        self.input_box.insert(0, "Measure exactly 4 liters using a 3L and a 5L jug.")
        self.input_box.grid(row=0, column=0, sticky="ew", pady=(0, 15))

        self.tab_view = ctk.CTkTabview(content_frame)
        self.tab_view.grid(row=1, column=0, sticky="nsew")
        self.tab_view.add("üí¨ Chat History")
        self.tab_view.add("üå≥ Live Logic Tree")

        # Tab 1: Chat History
        self.chat_scroll = ctk.CTkScrollableFrame(self.tab_view.tab("üí¨ Chat History"), fg_color="transparent")
        self.chat_scroll.pack(fill="both", expand=True)

        # Tab 2: Logic Tree
        tree_tab = self.tab_view.tab("üå≥ Live Logic Tree")
        tree_tab.grid_rowconfigure(0, weight=2)
        tree_tab.grid_rowconfigure(1, weight=1)
        tree_tab.grid_columnconfigure(0, weight=1)

        tree_frame = ctk.CTkFrame(tree_tab, fg_color="transparent")
        tree_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))

        columns = ("score", "type")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="tree headings")
        self.tree.heading("#0", text="Reasoning Step")
        self.tree.heading("score", text="Score")
        self.tree.heading("type", text="Type")
        self.tree.column("#0", width=600)
        self.tree.column("score", width=80, anchor="center")
        self.tree.column("type", width=100, anchor="center")
        self.tree.bind("<<TreeviewSelect>>", self.on_tree_select)

        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscroll=scrollbar.set)
        self.tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.tree.tag_configure("solution", foreground="#52c41a")
        self.tree.tag_configure("refute", foreground="#ff4d4f")
        self.tree.tag_configure("idea", foreground="#40a9ff")
        self.tree.tag_configure("root", foreground="#ffffff")

        detail_frame = ctk.CTkFrame(tree_tab)
        detail_frame.grid(row=1, column=0, sticky="nsew")
        ctk.CTkLabel(detail_frame, text="Selected Step Details:", font=ctk.CTkFont(size=12, weight="bold")).pack(
            anchor="w", padx=5, pady=2)
        self.detail_box = ctk.CTkTextbox(detail_frame, height=100, font=ctk.CTkFont(family="Consolas", size=12))
        self.detail_box.pack(fill="both", expand=True, padx=5, pady=5)

    def on_tree_select(self, event):
        """Displays full text for selected tree node."""
        selected_items = self.tree.selection()
        if not selected_items: return
        item_id = selected_items[0]
        if hasattr(self, 'node_map') and item_id in self.node_map:
            text = self.node_map[item_id]
            self.detail_box.delete("0.0", "end")
            self.detail_box.insert("0.0", text)

    def add_chat_bubble(self, role, text):
        """Adds a message to the chat history scrollable frame."""
        bubble_frame = ctk.CTkFrame(self.chat_scroll, fg_color="transparent")
        bubble_frame.pack(fill="x", pady=10)

        if role == "User":
            lbl = ctk.CTkLabel(bubble_frame, text=role, text_color="#40a9ff", font=("Arial", 11, "bold"))
            lbl.pack(anchor="e", padx=10)
            box = ctk.CTkTextbox(bubble_frame, height=50, fg_color="#1f2937", text_color="white",
                                 activate_scrollbars=False, font=("Arial", 13))
            box.pack(anchor="e", padx=10, fill="x")
        else:
            lbl = ctk.CTkLabel(bubble_frame, text=f"AI ({self.mode_var.get()})", text_color="#52c41a",
                               font=("Arial", 11, "bold"))
            lbl.pack(anchor="w", padx=10)
            box = ctk.CTkTextbox(bubble_frame, height=100, fg_color="#2b2b2b", text_color="#e0e0e0",
                                 font=("Consolas", 13))
            box.pack(anchor="w", padx=10, fill="x")

        box.insert("0.0", text)
        box.configure(state="disabled")

        line_count = text.count('\n') + 1
        char_count = len(text)
        approx_lines = line_count + (char_count // 90)
        new_height = min(600, max(50, approx_lines * 22 + 20))
        box.configure(height=new_height)

    def _process_queue(self):
        """Polls the background thread queue and updates UI components."""
        if self.is_running:
            elapsed = time.time() - self.start_time
            self.status_label.configure(text=f"Thinking... ({elapsed:.1f}s)")

            # Polling the active searcher for tree visualization
            if self.current_searcher and self.current_searcher.root:
                self.populate_tree(self.current_searcher.root)

        try:
            while True:
                msg_type, data = self.msg_queue.get_nowait()
                if msg_type == "status":
                    pass
                elif msg_type == "final_result":
                    self.add_chat_bubble("AI", data)
                    self.tab_view.set("üí¨ Chat History")
                elif msg_type == "error":
                    self.add_chat_bubble("System", f"ERROR: {data}")
                elif msg_type == "done":
                    self.is_running = False
                    self.current_searcher = None
                    self.action_btn.configure(text="Start Reasoning", fg_color=["#3B8ED0", "#1F6AA5"])
                    self.status_label.configure(text="Ready")
        except queue.Empty:
            pass
        finally:
            self.after(500, self._process_queue)

    def toggle_search(self):
        """Handles Start/Abort logic."""
        if self.is_running:
            self.is_running = False
            self.status_label.configure(text="Stopping...")
            self.action_btn.configure(text="Start Reasoning")
            return

        question = self.input_box.get()
        if not question: return

        self.is_running = True
        self.start_time = time.time()
        self.action_btn.configure(text="ABORT", fg_color="#ff4d4f", hover_color="#d9363e")
        self.tree.delete(*self.tree.get_children())
        self.detail_box.delete("0.0", "end")
        self.tab_view.set("üå≥ Live Logic Tree")
        self.node_map = {}
        self.add_chat_bubble("User", question)

        mode = self.mode_var.get()
        threading.Thread(target=self.run_logic, args=(question, mode), daemon=True).start()

    def run_logic(self, question, mode_name):
        try:
            if not self.engine:
                self.msg_queue.put(("status", "Loading Engine..."))
                self.engine = ChatEngine()

            config = MODES[mode_name]

            # --- FLASH MODE ---
            if config["type"] == "direct":
                self.engine.history.append({"role": "user", "content": question})
                response = self.engine.generate_answer(self.engine.history, temperature=0.7)
                if response:
                    txt = response['choices'][0]['message']['content']
                    self.engine.history.append({"role": "assistant", "content": txt})
                    self.msg_queue.put(("final_result", txt))
                self.msg_queue.put(("done", True))
                return

            # --- SEARCH MODE ---
            searcher = BeamSearch(
                engine=self.engine,
                max_breadth=config["width"],
                max_depth=config["depth"],
                max_retries=config["retries"]
            )

            self.current_searcher = searcher
            result_history = searcher.search(question)

            if result_history:
                # Append the winning reasoning chain to the main engine history.
                # result_history includes [UserQ, Step1, Step2, ..., Solution]
                # This ensures future Flash queries have context of the logic path.
                self.engine.history.extend(result_history)

                formatted_chain = ""
                step_count = 1
                for msg in result_history:
                    if msg['role'] == 'assistant':
                        content = msg['content'].strip()
                        clean_content = content.replace("step:", "").replace("solution:", "").strip()

                        if "solution:" in content.lower() or "solved" in content.lower():
                            formatted_chain += f"\nüèÜ **CONCLUSION**:\n{clean_content}\n"
                        else:
                            formatted_chain += f"üîπ **Step {step_count}**:\n{clean_content}\n\n"
                            step_count += 1

                self.msg_queue.put(("final_result", formatted_chain))
            else:
                self.msg_queue.put(("error", "No solution found after all attempts."))

        except Exception as e:
            self.msg_queue.put(("error", str(e)))
        finally:
            self.msg_queue.put(("done", True))

    def populate_tree(self, root_node):
        """Visualizes the current state of the BeamSearch tree."""
        if not root_node: return

        # Note: Full redraw is used for simplicity.
        # In production with massive trees, delta updates would be preferred.
        self.tree.delete(*self.tree.get_children())
        queue = [(root_node, "")]
        while queue:
            node, parent_id = queue.pop(0)
            node_id = str(id(node))
            self.node_map[node_id] = node.content

            content_lower = node.content.lower()
            tag = "idea";
            tag_text = "Step"
            if node.depth == 0:
                tag = "root"; tag_text = "Problem"
            elif "solution:" in content_lower or "solved" in content_lower:
                tag = "solution"; tag_text = "Solution"
            elif "refute:" in content_lower:
                tag = "refute"; tag_text = "Critique"

            preview = node.content.replace('\n', ' ')[:80] + "..."
            score = f"{getattr(node, 'value', 0.0):.2f}"
            self.tree.insert(parent_id, "end", iid=node_id, text=preview, values=(score, tag_text), tags=(tag,),
                             open=True)
            for child in node.children: queue.append((child, node_id))


if __name__ == "__main__":
    app = ModernReasoningApp()
    app.mainloop()